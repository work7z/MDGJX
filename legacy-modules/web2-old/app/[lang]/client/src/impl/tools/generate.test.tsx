
import { expect, test } from 'vitest'
import { render, screen } from '@testing-library/react'
import { DataTypes, Model } from 'sequelize'
import ToBase64 from './impl/conversion/ToBase64'
import { OpDetail } from './s_tools'
import appToolInfoObj, { AppInfoType } from './d_meta'
import { ToolHandler } from './r_handler'
import fs from 'fs'
import FromBase64 from './impl/conversion/FromBase64'
import _ from 'lodash'
import path from 'path'
import TranslationUtils from '../../../../../__CORE__/utils/TranslationUtils'
import Operation from '../core/Operation'
import { getToolSubCategory } from './d_subcategory'

test('generate-app-op-detail-list', async () => {
    // FIRST PART
    // FIRST PART
    // FIRST PART
    // FIRST PART

    // list all tsx files in the folder __dirname/impl/conversion/, and filter files name starting with _
    let conversionFiles: { [key: string]: string } = {}
    // no, do not use meta but use fs
    let dirpath = __dirname + '/impl/conversion/'
    fs.readdirSync(dirpath).forEach(file => {
        if (file.startsWith('_')) return
        conversionFiles[file] = fs.readFileSync(dirpath + file, { encoding: 'utf-8' })
    })
    let fullStr: string[] = []

    _.forEach(conversionFiles, (x, d, n) => {
        let currentArr: string[] = []
        let collectedOptMode = false;
        let optDescArr: string[] = []
        let hasDOTForDesc = false
        let st_countBracketForOptDesc = 0;
        let ed_countBracketForOptDesc = 0;
        x = x.replace(/\s+Dot/g, 'Dot')
        x.split('\n').filter(xx => {
            if (xx.indexOf("optName") != -1) {
                currentArr.push(xx)
                return;
            }
            if (xx.indexOf("optDescription") != -1) {
                hasDOTForDesc = xx.indexOf("Dot") != -1
                if (!hasDOTForDesc) {
                    return;
                }
                collectedOptMode = true;
                // if(!hasDOTForDesc){
                //     currentArr.push(xx)
                //     return;
                // }
            }
            let dotMode = false;
            if (collectedOptMode) {
                // if (xx.indexOf("(") != -1) {
                //     st_countBracketForOptDesc++
                // }
                // if (xx.indexOf(")") != -1) {
                //     ed_countBracketForOptDesc++;
                // }
                optDescArr.push(xx)
                if (
                    (!hasDOTForDesc &&
                        xx.endsWith(",")) ||
                    // ed_countBracketForOptDesc > st_countBracketForOptDesc
                    xx.indexOf("),") != -1
                    ||
                    xx.endsWith(")")
                ) {
                    collectedOptMode = false
                    currentArr.push(optDescArr.filter(x => !_.isEmpty(x)).join("\n"))
                }
            }
        })
        let crtArrStr = `${d.replace('.tsx', '')}:({Dot})=>{
            return {
                // DO NOT CHANGE THIS PART AS THIS WHOLE FILE IS GENERATED BY SYSTEM
            ${currentArr.join('\n')}
            }
        }`
        fullStr.push(crtArrStr)

    })


    let fileTxt = ` // DO NOT TOUCH THIS FILE, AUTO GENERATED BY SYSTEM
//    Copyright
    import {AppOpFnMapType} from './d_meta';
    
   export  const AppOptFnMap ={
${fullStr.join(',\n')}
    } satisfies AppOpFnMapType
    export let getAppOptFnMap=():AppOpFnMapType=>{
        return AppOptFnMap
    } 
export type AppOpFnMapTypeKeys = keyof typeof AppOptFnMap;
    
    ` + ''
    console.log(fileTxt)


    // SECOND PART
    // SECOND PART
    // SECOND PART
    // SECOND PART
    // SECOND PART
    TranslationUtils.disableLanguageCheck = true;
    type Tool2PageMap = {
        [key: string]: {
            pagePath: string[]
        }[]
    }
    let tool2PageMapInst: Tool2PageMap = {}
    let subCategoryList = getToolSubCategory()
    _.forEach(subCategoryList, category => {
        _.forEach(category.subTabs, subTab => {
            let toolId = subTab.toolId
            if (!toolId) {
                return;
            }
            let inst = tool2PageMapInst[toolId] || []
            inst.push({ pagePath: [category.id, subTab.id] })
            tool2PageMapInst[toolId] = inst;
        })
    })

    fileTxt = fileTxt + `
    // DO NOT TOUCH THIS FILE, AUTO GENERATED BY SYSTEM
export    type Tool2PageMap = {
        [key: string]: {
            pagePath: string[]
        }[]
    }

// DO NOT TOUCH THIS FILE, AUTO GENERATED BY SYSTEM
    export const appTool2PageMap:Tool2PageMap = ${JSON.stringify(tool2PageMapInst, null, 4)}
// DO NOT TOUCH THIS FILE, AUTO GENERATED BY SYSTEM
    `

    let finalFile = path.join(__dirname, 'g_optlist.tsx')
    fs.writeFileSync(finalFile, fileTxt)



    expect(1 + 1).toBe(2)
})
